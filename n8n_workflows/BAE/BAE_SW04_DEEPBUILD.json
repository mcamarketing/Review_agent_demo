{
  "name": "BAE_SW04_DEEPBUILD",
  "nodes": [
    {
      "id": "node-recv",
      "name": "RECEIVE_TOP3",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [100, 400],
      "parameters": {}
    },
    {
      "id": "node-split",
      "name": "SPLIT_CONTENDERS",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [300, 400],
      "parameters": {
        "batchSize": 1,
        "options": {}
      }
    },
    {
      "id": "node-init",
      "name": "INIT_LOOP_STATE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [500, 400],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// ── LOOP STATE INITIALIZER ───────────────────────────────────────────────\n// Extracts the correct contender for this batch, sets up the loop state,\n// and builds the static build system prompt.\n// The static BUILD_SYS string is byte-for-byte identical on every loop\n// iteration, ensuring DeepSeek KV cache prefix matching works.\n\nconst item  = $input.first().json;\nif (item._loop_initialized) return [$input.first()];\n\nconst d          = item;\nconst contenders = d.top_3 || [];\nconst weights    = d.weights  || { revenue:0.30, speed:0.25, automation:0.20, margin:0.15, founder_dependence:0.10 };\nconst run_id     = d.run_id;\nconst intake     = d.intake;\n\n// SPLIT_CONTENDERS gives us one contender per batch — take the first item\nconst contender = contenders[$runIndex] || contenders[0];\n\n// ── STATIC BUILD SYSTEM PROMPT ──────────────────────────────────────────\n// NEVER modify this string at runtime — cache invalidation = cost spike.\n// DeepSeek-R1 prefix cache hit: $0.014/1M vs $0.28/1M cache miss.\nconst BUILD_SYS = `TOKEN BUDGET:700. Strict JSON only.\nROLE: Business execution architect. Build a complete, actionable 90-day execution plan.\nOUTPUT EXACTLY this JSON structure (no other keys, no markdown):\n{\n  \"contender_id\": string,\n  \"build_pass\": number,\n  \"go_to_market_plan\": {\n    \"week_1_actions\": [string, string, string],\n    \"week_2_4_actions\": [string, string, string],\n    \"month_2_3_actions\": [string, string, string]\n  },\n  \"automation_stack\": {\n    \"tools\": [string],\n    \"workflows_required\": [string],\n    \"estimated_setup_hrs\": number\n  },\n  \"revenue_model_detail\": {\n    \"pricing_tiers\": [\n      { \"name\": string, \"price_usd\": number, \"value_prop\": string }\n    ],\n    \"month_1_target\": number,\n    \"month_3_target\": number,\n    \"month_6_target\": number\n  },\n  \"refined_scores\": {\n    \"revenue_score\": number,\n    \"speed_score\": number,\n    \"automation_score\": number,\n    \"margin_score\": number,\n    \"founder_dependence_score\": number\n  }\n}\nRULES:\n- Use real tool names (n8n, Make.com, Stripe, Notion, Airtable, Zapier, etc.).\n- Revenue targets must be conservative and realistic for a solo founder.\n- refined_scores must reflect the actual quality of the plan you produce.\n- founder_dependence_score: 0=fully automated, 100=owner must be present every hour.\nNEVER output markdown. OUTPUT JSON ONLY.`;\n\nreturn [{ json: {\n  run_id,\n  weights,\n  intake,\n  contender,\n  build:              null,\n  scores:             null,\n  pass:               0,\n  loop_done:          false,\n  build_system_prompt: BUILD_SYS,\n  _loop_initialized:  true\n} }];"
      }
    },
    {
      "id": "node-loop-ctrl",
      "name": "LOOP_CONTROLLER",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [700, 400],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// ── REFINEMENT LOOP CONTROLLER ──────────────────────────────────────────\n// Decides: exit loop (pass/fail) or continue to next refinement pass.\n// Max 3 passes. Score gate: 75. Weak dimensions fed back to LLM prompt.\n\nconst MAX_PASS  = 3;\nconst PASS_GATE = 75;\n\nconst d = $input.first().json;\nconst state = {\n  run_id:             d.run_id,\n  weights:            d.weights,\n  intake:             d.intake,\n  contender:          d.contender,\n  build:              d.build     || null,\n  scores:             d.scores    || null,\n  pass:               d.pass      ?? 0,\n  build_system_prompt: d.build_system_prompt,\n  _loop_initialized:  true\n};\n\n// ── EXIT: score gate passed ────────────────────────────────────────────\nif (state.scores && state.scores.finalScore >= PASS_GATE) {\n  return [{ json: { ...state, status: 'passed', loop_done: true } }];\n}\n\n// ── EXIT: max passes exhausted ─────────────────────────────────────────\nif (state.pass >= MAX_PASS) {\n  return [{ json: {\n    ...state,\n    status:    'hard_fail',\n    loop_done: true,\n    error:     `Hard fail: ${MAX_PASS} refinement passes exhausted. finalScore=${\n      state.scores?.finalScore ?? 'N/A'\n    }`\n  } }];\n}\n\n// ── CONTINUE: build refinement context ────────────────────────────────\nconst refinement_context = state.build ? {\n  previous_score:  state.scores?.finalScore,\n  weak_dimensions: Object.entries(state.scores?.raw_scores || {})\n    .filter(([, v]) => v < 60)\n    .map(([k]) => k)\n} : null;\n\n// ── Build user prompt (initial vs refinement) ──────────────────────────\nlet user_prompt;\nif (!refinement_context) {\n  // Pass 1: fresh build\n  user_prompt = `Build a complete 90-day execution plan for this business model.\nCONTENDER: ${JSON.stringify(state.contender)}\nCLIENT WEIGHTS: ${JSON.stringify(state.weights)}\nCLIENT CONSTRAINTS: budget_usd=${state.intake?.budget_usd}, hrs_per_week=${state.intake?.founder_hours_per_week}, automation_pref=${state.intake?.automation_preference}\nOutput JSON only matching the schema.`;\n} else {\n  // Pass 2-3: targeted refinement on weak dimensions only\n  user_prompt = `REFINE this execution plan. Previous score: ${refinement_context.previous_score}/100.\nWEAK DIMENSIONS (score < 60, must improve): ${JSON.stringify(refinement_context.weak_dimensions)}.\nIMPROVE ONLY these dimensions. Do not reduce scores in other dimensions.\nCONTENDER: ${JSON.stringify(state.contender)}\nPREVIOUS BUILD (for context): ${JSON.stringify(state.build)}\nOutput JSON only matching the schema.`;\n}\n\nreturn [{ json: {\n  ...state,\n  pass:               state.pass + 1,\n  refinement_context,\n  user_prompt,\n  loop_done:          false,\n  status:             'running'\n} }];"
      }
    },
    {
      "id": "node-if-done",
      "name": "IF_LOOP_DONE",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [920, 400],
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true, "leftValue": "", "typeValidation": "strict" },
          "conditions": [{
            "id": "c1",
            "leftValue":  "={{ $json.loop_done }}",
            "rightValue": true,
            "operator": { "type": "boolean", "operation": "equal" }
          }],
          "combinator": "and"
        }
      }
    },
    {
      "id": "node-if-fail",
      "name": "IF_HARD_FAIL",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1140, 220],
      "parameters": {
        "conditions": {
          "options": { "caseSensitive": true },
          "conditions": [{
            "id": "c2",
            "leftValue":  "={{ $json.status }}",
            "rightValue": "hard_fail",
            "operator": { "type": "string", "operation": "equals" }
          }],
          "combinator": "and"
        }
      }
    },
    {
      "id": "node-pg-fail",
      "name": "PG_WRITE_HARD_FAIL",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1360, 100],
      "credentials": { "postgres": { "id": "postgres-main", "name": "postgresMain" } },
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO builds (run_id, contender_id, pass_number, build_data, score, status)\nVALUES (\n  '{{ $json.run_id }}'::uuid,\n  '{{ $json.contender.id }}',\n  {{ $json.pass }},\n  '{{ JSON.stringify($json.build || {}) }}'::jsonb,\n  {{ $json.scores?.finalScore || 0 }},\n  'hard_fail'\n);\nINSERT INTO errors (run_id, workflow_name, node_name, error_type, error_detail)\nVALUES (\n  '{{ $json.run_id }}'::uuid,\n  'BAE_SW04_DEEPBUILD',\n  'LOOP_CONTROLLER',\n  'HARD_FAIL',\n  '{{ $json.error }}'\n);",
        "options": {}
      }
    },
    {
      "id": "node-build-llm",
      "name": "HTTP_DEEP_BUILD_LLM",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4,
      "position": [1140, 560],
      "parameters": {
        "method": "POST",
        "url": "https://openrouter.ai/api/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Content-Type", "value": "application/json" },
            { "name": "HTTP-Referer", "value": "https://bae.local" },
            { "name": "X-Title",      "value": "BAE-DeepBuild" }
          ]
        },
        "sendBody": true,
        "contentType": "json",
        "body": {
          "model": "deepseek/deepseek-r1:free",
          "max_tokens": 700,
          "temperature": 0.4,
          "messages": [
            { "role": "system", "content": "={{ $json.build_system_prompt }}" },
            { "role": "user",   "content": "={{ $json.user_prompt }}" }
          ]
        },
        "options": { "timeout": 600000 }
      },
      "credentials": { "httpHeaderAuth": { "id": "openrouter-key", "name": "openRouterApiKey" } },
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetweenTries": 5000,
      "onError": "continueErrorOutput"
    },
    {
      "id": "node-validate-build",
      "name": "VALIDATE_BUILD_JSON",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1360, 560],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// ── BUILD JSON VALIDATOR & REPAIRER ────────────────────────────────────\n// Strips DeepSeek-R1 <thinking> traces, Markdown fences.\n// Three-stage repair pipeline. Falls back to minimal valid stub.\n// NEVER throws — always returns a valid item.\n\nfunction repairJson(raw) {\n  let t = (raw || '')\n    // DeepSeek-R1 emits <thinking>...</thinking> before the JSON\n    .replace(/<thinking>[\\s\\S]*?<\\/thinking>/gi, '')\n    .replace(/```json\\s*/gi, '')\n    .replace(/```\\s*/g, '')\n    .trim();\n\n  // Stage 1: Direct parse (fastest — works ~85% of time after strip)\n  try { return JSON.parse(t); } catch (_) {}\n\n  // Stage 2: Find outermost JSON container and slice to it\n  const fa = t.indexOf('['), fo = t.indexOf('{');\n  const start = (fa === -1) ? fo : (fo === -1) ? fa : Math.min(fa, fo);\n  if (start === -1) return null;\n  const opener    = t[start];\n  const closer    = opener === '[' ? ']' : '}';\n  const lastClose = t.lastIndexOf(closer);\n  t = lastClose === -1 ? t.slice(start) + closer : t.slice(start, lastClose + 1);\n\n  // Stage 3: Fix trailing commas (most common MoE hallucination)\n  t = t.replace(/,\\s*([\\]}])/g, '$1');\n  try { return JSON.parse(t); } catch (e) { return null; }\n}\n\nconst item = $input.first();\nconst prev = $('LOOP_CONTROLLER').first().json;\nconst raw  = item.json?.choices?.[0]?.message?.content\n           || item.json?.content?.[0]?.text || '';\n\nlet build = repairJson(raw);\n\n// ── Fallback: synthesize minimal valid build from contender data ──────\n// Pipeline continues with degraded quality — never crashes.\nif (!build || !build.refined_scores) {\n  const c = prev.contender || {};\n  build = {\n    contender_id: c.id,\n    build_pass:   (prev.pass || 1) - 1,\n    go_to_market_plan: {\n      week_1_actions:   ['Set up core automation', 'Configure payment processing', 'Create landing page'],\n      week_2_4_actions: ['Acquire first 3 paying clients', 'Refine offer based on feedback'],\n      month_2_3_actions: ['Scale acquisition channel', 'Automate client onboarding', 'Optimize pricing']\n    },\n    automation_stack: {\n      tools:                ['n8n', 'Stripe', 'Notion', 'Make.com'],\n      workflows_required:   ['Lead capture', 'Payment processing', 'Client onboarding', 'Delivery'],\n      estimated_setup_hrs:  20\n    },\n    revenue_model_detail: {\n      pricing_tiers:  [{ name: 'Starter', price_usd: c.month_1_revenue_usd || 500, value_prop: 'Core service delivery' }],\n      month_1_target: c.month_1_revenue_usd || 500,\n      month_3_target: Math.round((c.month_1_revenue_usd || 500) * 2.5),\n      month_6_target: c.month_6_revenue_usd || 3000\n    },\n    refined_scores: {\n      revenue_score:            55,\n      speed_score:              55,\n      automation_score:         (c.automation_score || 5) * 10,\n      margin_score:             c.gross_margin_pct || 55,\n      founder_dependence_score: 50\n    },\n    _fallback_build: true\n  };\n}\n\nbuild.contender_id = build.contender_id || prev.contender?.id;\nbuild.build_pass   = (prev.pass || 1) - 1;\n\nreturn [{ json: { ...prev, build, _raw_build: raw } }];"
      }
    },
    {
      "id": "node-score-build",
      "name": "SCORE_BUILD_NODE",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1580, 560],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// ── BUILD SCORER ────────────────────────────────────────────────────────\n// Re-scores the build using the refined_scores from the LLM output.\n// Uses the same adaptive weight vector from SW-01 for consistency.\n// founder_dependence is inverted: 100 dependence = 0 score (want independence).\n\nconst d       = $input.first().json;\nconst build   = d.build;\nconst weights = d.weights || { revenue:0.30, speed:0.25, automation:0.20, margin:0.15, founder_dependence:0.10 };\n\nconst rs = build?.refined_scores || {};\n\n// Map raw scores — invert founder_dependence\nconst raw = {\n  revenue:            Math.min(100, Math.max(0, rs.revenue_score            || 50)),\n  speed:              Math.min(100, Math.max(0, rs.speed_score              || 50)),\n  automation:         Math.min(100, Math.max(0, rs.automation_score         || 50)),\n  margin:             Math.min(100, Math.max(0, rs.margin_score             || 50)),\n  founder_dependence: Math.min(100, Math.max(0, 100 - (rs.founder_dependence_score || 50)))\n};\n\nconst weighted = {};\nlet finalScore = 0;\nfor (const k of Object.keys(weights)) {\n  weighted[k] = +(raw[k] * weights[k]).toFixed(4);\n  finalScore  += weighted[k];\n}\nfinalScore = +finalScore.toFixed(2);\n\nconst scores = { raw_scores: raw, weighted_components: weighted, weights, finalScore };\n\nreturn [{ json: { ...d, scores } }];"
      }
    },
    {
      "id": "node-pg-state-upsert",
      "name": "PG_UPSERT_BUILD_STATE",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1800, 560],
      "credentials": { "postgres": { "id": "postgres-main", "name": "postgresMain" } },
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO build_state (contender_id, run_id, iteration, plan_json, weak_dims, final_score, status, updated_at)\nVALUES (\n  '{{ $json.contender.id }}',\n  '{{ $json.run_id }}'::uuid,\n  {{ $json.pass }},\n  '{{ JSON.stringify($json.build) }}'::jsonb,\n  '{{ JSON.stringify(\n    Object.entries($json.scores.raw_scores || {})\n      .filter(([k, v]) => v < 60)\n      .map(([k]) => k)\n  ) }}'::jsonb,\n  {{ $json.scores.finalScore }},\n  'running',\n  NOW()\n)\nON CONFLICT (contender_id)\nDO UPDATE SET\n  iteration   = EXCLUDED.iteration,\n  plan_json   = EXCLUDED.plan_json,\n  weak_dims   = EXCLUDED.weak_dims,\n  final_score = EXCLUDED.final_score,\n  status      = EXCLUDED.status,\n  updated_at  = NOW();",
        "options": {}
      }
    },
    {
      "id": "node-pg-build-insert",
      "name": "PG_INSERT_BUILD",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [2020, 560],
      "credentials": { "postgres": { "id": "postgres-main", "name": "postgresMain" } },
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO builds (run_id, contender_id, pass_number, build_data, score, status, weak_dims)\nVALUES (\n  '{{ $json.run_id }}'::uuid,\n  '{{ $json.contender.id }}',\n  {{ $json.pass }},\n  '{{ JSON.stringify($json.build) }}'::jsonb,\n  {{ $json.scores.finalScore }},\n  'refinement',\n  '{{ JSON.stringify(\n    Object.entries($json.scores.raw_scores || {})\n      .filter(([k, v]) => v < 60)\n      .map(([k]) => k)\n  ) }}'::jsonb\n)\nON CONFLICT (run_id, contender_id, pass_number) DO UPDATE\n  SET build_data = EXCLUDED.build_data,\n      score      = EXCLUDED.score,\n      status     = EXCLUDED.status;",
        "options": {}
      }
    },
    {
      "id": "node-loop-back",
      "name": "LOOP_BACK_TO_CONTROLLER",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [2240, 560],
      "parameters": {}
    },
    {
      "id": "node-collect-passed",
      "name": "COLLECT_PASSED_BUILDS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1360, 340],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// Collect the completed build item and update build_state final status\nconst d = $input.first().json;\nreturn [{ json: { ...d, status: 'passed' } }];"
      }
    },
    {
      "id": "node-pg-passed",
      "name": "PG_FINALIZE_PASSED",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1580, 340],
      "credentials": { "postgres": { "id": "postgres-main", "name": "postgresMain" } },
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE build_state SET status='passed', updated_at=NOW()\nWHERE contender_id='{{ $json.contender.id }}';\nINSERT INTO builds (run_id, contender_id, pass_number, build_data, score, status)\nVALUES (\n  '{{ $json.run_id }}'::uuid,\n  '{{ $json.contender.id }}',\n  {{ $json.pass }},\n  '{{ JSON.stringify($json.build) }}'::jsonb,\n  {{ $json.scores.finalScore }},\n  'passed'\n)\nON CONFLICT (run_id, contender_id, pass_number) DO UPDATE\n  SET score  = EXCLUDED.score,\n      status = EXCLUDED.status;",
        "options": {}
      }
    },
    {
      "id": "node-aggregate",
      "name": "AGGREGATE_ALL_BUILDS",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1820, 340],
      "parameters": {
        "mode": "runOnceForAllItems",
        "jsCode": "// ── AGGREGATE ALL BUILT CONTENDERS ──────────────────────────────────────\n// Runs after all 3 contenders have completed (passed or hard_failed).\n// Collects all items and packages them for SW-05.\n\nconst all = $input.all().map(i => i.json);\nconst run_id  = all.find(d => d.run_id)?.run_id;\nconst weights = all.find(d => d.weights)?.weights;\nconst intake  = all.find(d => d.intake)?.intake;\n\nreturn [{ json: {\n  run_id,\n  weights,\n  intake,\n  built_contenders: all\n} }];"
      }
    },
    {
      "id": "node-run-sw05",
      "name": "RUN_SW05_AUDIT",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [2060, 340],
      "parameters": {
        "workflowId": { "__rl": true, "mode": "name", "value": "BAE_SW05_AUDIT" },
        "waitForSubWorkflow": true,
        "options": {}
      }
    },
    {
      "id": "node-dlq-build",
      "name": "DLQ_BUILD_FAILURE",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [1360, 720],
      "credentials": { "postgres": { "id": "postgres-main", "name": "postgresMain" } },
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO dlq_failures (run_id, workflow_name, node_name, error_code, error_message, raw_payload)\nVALUES (\n  '{{ $('LOOP_CONTROLLER').first().json.run_id }}'::uuid,\n  'BAE_SW04_DEEPBUILD',\n  'HTTP_DEEP_BUILD_LLM',\n  '{{ $json.statusCode }}',\n  '{{ $json.message }}',\n  '{{ JSON.stringify($json) }}'::jsonb\n);",
        "options": {}
      }
    }
  ],
  "connections": {
    "RECEIVE_TOP3":          { "main": [[{ "node": "SPLIT_CONTENDERS",      "type": "main", "index": 0 }]] },
    "SPLIT_CONTENDERS":      { "main": [[{ "node": "INIT_LOOP_STATE",       "type": "main", "index": 0 }]] },
    "INIT_LOOP_STATE":       { "main": [[{ "node": "LOOP_CONTROLLER",       "type": "main", "index": 0 }]] },
    "LOOP_CONTROLLER":       { "main": [[{ "node": "IF_LOOP_DONE",          "type": "main", "index": 0 }]] },
    "IF_LOOP_DONE":          {
      "main": [
        [{ "node": "IF_HARD_FAIL",         "type": "main", "index": 0 }],
        [{ "node": "HTTP_DEEP_BUILD_LLM",  "type": "main", "index": 0 }]
      ]
    },
    "IF_HARD_FAIL":          {
      "main": [
        [{ "node": "PG_WRITE_HARD_FAIL",   "type": "main", "index": 0 }],
        [{ "node": "COLLECT_PASSED_BUILDS", "type": "main", "index": 0 }]
      ]
    },
    "HTTP_DEEP_BUILD_LLM":   {
      "main":  [[{ "node": "VALIDATE_BUILD_JSON",  "type": "main", "index": 0 }]],
      "error": [[{ "node": "DLQ_BUILD_FAILURE",    "type": "main", "index": 0 }]]
    },
    "VALIDATE_BUILD_JSON":   { "main": [[{ "node": "SCORE_BUILD_NODE",      "type": "main", "index": 0 }]] },
    "SCORE_BUILD_NODE":      { "main": [[{ "node": "PG_UPSERT_BUILD_STATE", "type": "main", "index": 0 }]] },
    "PG_UPSERT_BUILD_STATE": { "main": [[{ "node": "PG_INSERT_BUILD",       "type": "main", "index": 0 }]] },
    "PG_INSERT_BUILD":       { "main": [[{ "node": "LOOP_BACK_TO_CONTROLLER","type": "main", "index": 0 }]] },
    "LOOP_BACK_TO_CONTROLLER":{ "main": [[{ "node": "LOOP_CONTROLLER",      "type": "main", "index": 0 }]] },
    "COLLECT_PASSED_BUILDS": { "main": [[{ "node": "PG_FINALIZE_PASSED",    "type": "main", "index": 0 }]] },
    "PG_FINALIZE_PASSED":    { "main": [[{ "node": "AGGREGATE_ALL_BUILDS",  "type": "main", "index": 0 }]] },
    "AGGREGATE_ALL_BUILDS":  { "main": [[{ "node": "RUN_SW05_AUDIT",        "type": "main", "index": 0 }]] }
  },
  "settings": { "executionOrder": "v1" },
  "meta": { "instanceId": "bae-instance" }
}
